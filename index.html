<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js Cube Grid</title>
  <style>
    body { margin: 0; background-color: #0f1014; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202533);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 20);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    const boardGroup = new THREE.Group();
    scene.add(boardGroup);

    const gridSize = 10;
    const spacing = 1.4;
    const totalSpan = (gridSize - 1) * spacing;
    const offset = totalSpan / 2;

    const geometry = new THREE.BoxGeometry(1, 1, 1);
    const colorPalette = [0xff5533, 0x209cee, 0xffdd57, 0x23d160, 0xb86bff, 0xff9f1c];
    const materials = colorPalette.map(color => new THREE.MeshStandardMaterial({ color }));

    const cubeGroup = new THREE.Group();
    const cubeGrid = Array.from({ length: gridSize }, () => Array(gridSize).fill(null));

    function setCubePosition(cube, row, col) {
      const x = col * spacing - offset;
      const z = row * spacing - offset;
      cube.position.set(x, 0, z);
    }

    for (let row = 0; row < gridSize; row += 1) {
      for (let col = 0; col < gridSize; col += 1) {
        const material = materials[Math.floor(Math.random() * materials.length)];
        const cube = new THREE.Mesh(geometry, material);
        setCubePosition(cube, row, col);
        cubeGroup.add(cube);
        cubeGrid[row][col] = cube;
      }
    }

    boardGroup.add(cubeGroup);

    const cursorEdgesGeometry = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.05, 1.05, 1.05));
    const cursorMaterial = new THREE.LineBasicMaterial({ color: 0xffffff });
    cursorMaterial.depthTest = false;
    cursorMaterial.depthWrite = false;

    const cursorLeft = new THREE.LineSegments(cursorEdgesGeometry, cursorMaterial);
    const cursorRight = new THREE.LineSegments(cursorEdgesGeometry, cursorMaterial);
    cursorLeft.position.x = -spacing / 2;
    cursorRight.position.x = spacing / 2;
    cursorLeft.position.y = 0.02;
    cursorRight.position.y = 0.02;

    const cursorGroup = new THREE.Group();
    cursorGroup.add(cursorLeft, cursorRight);
    cursorGroup.renderOrder = 1;
    boardGroup.add(cursorGroup);

    const cursorState = {
      col: Math.floor((gridSize - 2) / 2),
      row: Math.floor((gridSize - 1) / 2),
    };

    const swapDurationMs = 100;
    let isSwapInProgress = false;
    let currentSwap = null;

    const updateCursorPosition = () => {
      const x = (cursorState.col + 0.5) * spacing - offset;
      const z = cursorState.row * spacing - offset;
      cursorGroup.position.set(x, 0, z);
    };

    const swapSelectedCubes = () => {
      if (isSwapInProgress) {
        return;
      }

      const row = cursorState.row;
      const leftCol = cursorState.col;
      const rightCol = leftCol + 1;
      const leftCube = cubeGrid[row][leftCol];
      const rightCube = cubeGrid[row][rightCol];

      if (!leftCube || !rightCube) {
        return;
      }

      const swapStart = performance.now();
      const leftStart = leftCube.position.clone();
      const rightStart = rightCube.position.clone();
      const leftTarget = new THREE.Vector3(rightCol * spacing - offset, 0, row * spacing - offset);
      const rightTarget = new THREE.Vector3(leftCol * spacing - offset, 0, row * spacing - offset);

      isSwapInProgress = true;
      currentSwap = {
        row,
        leftCol,
        rightCol,
        leftCube,
        rightCube,
        startTime: swapStart,
        duration: swapDurationMs,
        leftStart,
        rightStart,
        leftTarget,
        rightTarget,
      };
    };

    updateCursorPosition();

    boardGroup.rotation.x = -Math.PI / 2;
    boardGroup.scale.z = -1;

    const updateSwapAnimation = (time = performance.now()) => {
      if (!currentSwap) {
        return;
      }

      const elapsed = time - currentSwap.startTime;
      const progress = Math.min(elapsed / currentSwap.duration, 1);

      currentSwap.leftCube.position.lerpVectors(currentSwap.leftStart, currentSwap.leftTarget, progress);
      currentSwap.rightCube.position.lerpVectors(currentSwap.rightStart, currentSwap.rightTarget, progress);

      if (progress >= 1) {
        cubeGrid[currentSwap.row][currentSwap.leftCol] = currentSwap.rightCube;
        cubeGrid[currentSwap.row][currentSwap.rightCol] = currentSwap.leftCube;

        setCubePosition(currentSwap.rightCube, currentSwap.row, currentSwap.leftCol);
        setCubePosition(currentSwap.leftCube, currentSwap.row, currentSwap.rightCol);

        currentSwap = null;
        isSwapInProgress = false;
      }
    };

    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(6, 10, 8);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const handleResize = () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    };
    window.addEventListener('resize', handleResize);

    const handleKeyDown = (event) => {
      let moved = false;

      switch (event.key) {
        case 'ArrowLeft':
          if (cursorState.col > 0) {
            cursorState.col -= 1;
            moved = true;
          }
          break;
        case 'ArrowRight':
          if (cursorState.col < gridSize - 2) {
            cursorState.col += 1;
            moved = true;
          }
          break;
        case 'ArrowUp':
          if (cursorState.row > 0) {
            cursorState.row -= 1;
            moved = true;
          }
          break;
        case 'ArrowDown':
          if (cursorState.row < gridSize - 1) {
            cursorState.row += 1;
            moved = true;
          }
          break;
        default:
          break;
      }

      if (moved) {
        event.preventDefault();
        updateCursorPosition();
        return;
      }

      if (event.code === 'Space' || event.key === ' ' || event.key === 'Spacebar') {
        event.preventDefault();

        if (!isSwapInProgress) {
          swapSelectedCubes();
        }
      }
    };

    window.addEventListener('keydown', handleKeyDown);

    const animate = (time) => {
      updateSwapAnimation(time);
      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    };

    requestAnimationFrame(animate);
  </script>
</body>
</html>
